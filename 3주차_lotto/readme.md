## ****3주차****

## Contents

- [****3주차****](#3주차)
- [Contents](#contents)
- [과제 목표](#과제-목표)
- [****학습 내용****](#학습-내용)
- [**📖 MVC**](#-mvc)
  - [모델](#모델)
  - [뷰](#뷰)
  - [컨트롤러](#컨트롤러)
  - [느낀점](#느낀점)
- [**📖 정적 팩토리 메서드**](#-정적-팩토리-메서드)
- [**📖 정규식**](#-정규식)
- [****기능 목록****](#기능-목록)
  - [🎯 프로젝트 개요](#-프로젝트-개요)
  - [🚀 기능목록](#-기능목록)
- [과제를 이해한 후 느낀점](#과제를-이해한-후-느낀점)

 
## 과제 목표

- 함수 분리
    
    함수별로 테스트를 작성
    
- [추가]
    
    **1. 클래스(객체)를 분리하는 연습**
    
    **2. 도메인 로직에 대한 단위 테스트를 작성하는 연습**
    
    (작은 기능부터 테스트를 작성하는 연습을 시작해 보는 것입니다.)    


## ****학습 내용****

이번 과제를 통해 하나의 메소드에 하나의 기능 구현과 클래스 분리를 중점적으로 연습 해보겠습니다.

## **📖 MVC**

이번에 처음 MVC모델을 알게되어 lotto 과제 설계에 적용해보았다

MVC 패턴은어플리케이션을 세가지 역할로 구분한 개발 방법론을 말한다

사용자가 입력을 담당하는 View를 통해 요청을 보내면 해당 요청을 컨트롤러가 받고

컨트롤러는 모델을 통해 데이터를 가져오고

해당 데이터를 바탕으로 출력을 담당하는 뷰를 제어해서 사용자에게 전달한다

MVC 패턴을 사용하면 모델과 뷰가 다른 컴포넌트들에 종속되지 않아

변경에 유리하다는 장점을 가진다

컴포넌트는 모델 뷰 컨트롤러가 있다

### 모델

어플리케이션에 무엇을 할 것인지 정의한다

내부 비즈니스 로직을 처리하기 위한 역할을 한다

데이터 저장소와 연동해 사용자가 입력한 데이터나 사용자에게 출력할 데이터를 다룬다

추가, 변경, 삭제와 같은 데이터 변경을 하나의 작업으로 묶은 트랜잭션을 다루는 일도 한다

모델은 다른 컴포넌트들에 대해 알지 못한다

자기 자신이 무엇을 수행하는지만 알고 있다

### 뷰

최종 사용자에게 무엇을 화면(UI)로 보여준다

즉 모델이 처리한 데이터나 그 작업 결과를 가지고 사용자에게 출력할 화면을 만든다

뷰 역시 다른 컴포넌트들에 알지 못한다

자기 자신이 무엇을 수행하는지만 알고 있다

### 컨트롤러

모델과 뷰 사이에 있는 컴포넌트이다

모델이 데이터를 어떻게 처리할 지 알려주는 역할을 한다

클라이언트의 요청을 받으면 해당 요청에 대한 업무를 수행하는 모델을 호출한다

클라이언트가 보낸 데이터가 있다면, 모델을 호출할 때 전달하기 쉽게 적절히 가공한다

예를들어 내가 이해한 로또를 사기위한 금액을 받아 Money 객체에 저장하는 과정은 다음과 같다

1. 뷰를 통해 String 받기
2. 모델로 전달하기 전 가공하기
   1. NULL인가 유효성 검사(utils)
   2. 숫자인가 유효성 검사(utils)
3. 모델로 전달
   1. 생성자에서 1000원 단위가 맞는지 유효성 검사

모델이 업무 수행을 완료하면 그 결과를 가지고 화면을 생성하도록 뷰에 전달한다

즉 클라이언트의 요청에 대해 모델과 뷰를 결정하여 전달하는 일정의 조정자로서의 일을 한다

컨트롤러는 다른 컴포넌트들에 대해 알고 있다 자기 자신 외에 모델과 뷰가 무엇을 수행하는지 안다

inputView를 통해 사용자로부터 입력을 받고

Model을 통해 내부 비즈니스 로직을 처리하고

outputView를 통해 사용자에게 화면을 출력한다

### 느낀점

프로그램 실행 환경이 바뀌었을때 모델은 그대로 사용하고 컨트롤러와 뷰만 새로 구현하면 된다는 것을 깨달았다

모델은 내부 비즈니스 로직을 가지기 때문에 보통 개발할 때 구현에 가장 오랜 시간이 걸린다

모델을 그대로 활용하니까 코드를 크게 변경하지 않아도 금세 새로운 환경에서 작동하는 어플리케이션을 만들 수 있을거라 생각한다

모델과 뷰가 다른 컴포넌트들에 독립적이게 만드는 것이 생각보다 어렵다는 것을 알게 되었다


<div align = "right">
	<b><a href = "#Contents">↥ top</a></b>
</div>

## **📖 정적 팩토리 메서드**

**이름을 가질 수 있다**

객체는 생성 목적과 과정에 따라 생성자를 구별해서 사용할 필요가 있다.

new 라는 키워드를 통해 객체를 생성하는 생성자는 내부 구조를 잘 알고 있어야 목적에 맞게 객체를 생성할 수 있다.

하지만 정적 팩토리 메서드를 사용하면 메서드 이름에 객체의 생성 목적을 담아 낼 수 있다.

```java
public class LottoFactory() {
  private static final int LOTTO_SIZE = 6;

  private static List<LottoNumber> allLottoNumbers = ...; // 1~45까지의 로또 넘버

  public static Lotto createAutoLotto() {
    Collections.shuffle(allLottoNumbers);
    return new Lotto(allLottoNumbers.stream()
            .limit(LOTTO_SIZE)
            .collect(Collectors.toList()));
  }

  public static Lotto createManualLotto(List<LottoNumber> lottoNumbers) {
    return new Lotto(lottoNumbers);
  }
  ...
}
```

메서드의 이름만 보아도 로또 객체를 자동으로 생성하는지, 아니면 수동으로 생성하는지 단번에 이해할 수 있을 것이다.

이처럼 정적 팩토리 메서드를 사용하면 해당 생성의 목적을 이름에 표현할 수 있어 가독성이 좋아지는 효과가 있다.

**호출할 때마다 새로운 객체를 생성할 필요가 없다.**

enum과 같이 자주 사용되는 요소의 개수가 정해져있다면 해당 개수만큼 미리 생성해놓고 조회(캐싱)할 수 있는 구조로 만들수 있다. 

**정적 팩터리 메서드**와 **캐싱구조**를 함께 사용하면 매번 새로운 객체를 생성할 필요가 없어진다.

```java
public class LottoNumber {
  private static final int MIN_LOTTO_NUMBER = 1;
  private static final int MAX_LOTTO_NUMBER = 45;

  private static Map<Integer, LottoNumber> lottoNumberCache = new HashMap<>();

  static {
    IntStream.range(MIN_LOTTO_NUMBER, MAX_LOTTO_NUMBER)
                .forEach(i -> lottoNumberCache.put(i, new LottoNumber(i)));
  }

  private int number;

  private LottoNumber(int number) {
    this.number = number;
  }

  public LottoNumber of(int number) {  // LottoNumber를 반환하는 정적 팩토리 메서드
    return lottoNumberCache.get(number);
  }

  ...
}
```

미리 생성된 로또 번호 객체의 캐싱을 통해서 새로운 객체 생성의 부담을 덜 수 있다는 장점도 있지만,

생성자의 접근 제한자를 `private`으로 설정함으로써 **객체 생성을 정적 팩토리 메서드로만 가능하도록 제한**할 수 있다는 것이다. 이를 통해 정해진 범위를 벗어나는 로또 번호의 생성을 막을 수 있다는 장점을 확보할 수 있다

****하위 자료형 객체를 반환할 수 있다.****

하위 자료형 객체를 반환하는 정적 팩토리 메서드의 특징은 상속을 사용할 때 확인할 수 있다. 

이는 생성자의 역할을 하는 정적 팩토리 메서드가 반환값을 가지고 있기 때문에 가능한 특징이다.

시험 점수에 따라 결정되는하위 등급 타입을 반환하는 정적 팩토리 메서드를 만들면, 

다음과 같이 분기처리를 통해 하위 타입의 객체를 반환할 수 있다.

```java
public class Level {
  ...
  public static Level of(int score) {
    if (score < 50) {
      return new Basic();
    } else if (score < 80) {
      return new Intermediate();
    } else {
      return new Advanced();
    }
  }
  ...
}
```

## **📖 정규식**

정규식 표현은 특정한 규칙을 가진 문자열의 집합을 표현하는데 사용되는 언어를 말한다

자바 utils.regex에서의 pattern이나 matches를 주로 사용한다

특정 문자열이 주어진 정규식에 매칭되는지 테스트가 가능하다


- replaceAll()

	문자열을 대체하는 메소드로

	replace와 두개가 있음

	replaceAll()은 정규표현식 사용이 가능

	String regex = "[0-9]";

	input = input.replaceAll(regex,"");
	
	숫자를 “”으로 지우고

	!input.matches(“[1-9]+[0-9]*”)를 확인

http://yoonbumtae.com/?p=1865


****객체 생성을 캡슐화할 수 있다.****

여러 번의 객체 생성이 필요한 경우라면 생성자보다는 정적 팩토리 메서드를 사용해보자.

<div align = "right">
	<b><a href = "#Contents">↥ top</a></b>
</div>

## ****기능 목록****

### 🎯 프로젝트 개요

로또 게임 기능을 구현합니다. 

로또 한 장의 가격은 1,000원 입니다.

숫자 1부터 45 범위 내의 숫자 중, 6개의 숫자를 자동으로 뽑습니다.

당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑습니다.

당첨 내역 및 수익률을 출력하고 로또 게임을 종료합니다.

### 🚀 기능목록

- [x] 로또 구입 금액을 입력받는 기능

    - [x] 구매 가능한 로또 개수 구하는 기능
    - [x] 공백이 있다면 제거
    - [x] (e) 공백인 경우 예외처리
    - [x] (e) 정수 입력이 아니면 예외처리
    - [x] (e) 음수이면 예외처리
    - [x] (e) 1000원 단위 외의 금액은 예외처리

    <br/>

- [x] 구매한 로또 개수 출력하는 기능

    <br/>

- [x] 로또 목록 기능
    - [x] 로또 티켓을 랜덤으로 생성하는 기능

    - [x] 로또 숫자 정렬하는 기능

    - [x] 생성된 티켓 목록을 출력하는 기능

    <br/>

- [x] 당첨 번호 입력받는 기능

    - [x] 공백 제거
    - [x] (e) 숫자가 아니면 예외처리
    - [x] (e) 숫자가 6개가 아니면 예외처리
    - [x] (e) 숫자가 1 ~ 45 범위가 아니면 예외처리
    - [x] (e) 입력 구분자가 , 가 아니면 예외처리
    - [x] (e) 중복된 숫자가 올 경우 예외처리

    <br/>

- [x] 보너스 번호 입력받는 기능

    - [x] 공백 제거
    - [x] (e) 숫자가 아니면 예외처리
    - [x] (e) 숫자는 1 ~ 45 범위가 아니면 예외처리
    - [x] (e) 당첨 번호와 중복되면 예외처리

    <br/>

- [x] 결과를 계산하는 기능

    - [x] 6등 확인 기능
    - [x] 5등 확인 기능
    - [x] 4등 확인 기능
    - [x] 3등 확인 기능
    - [x] 2등 확인 기능
    - [x] 1등 확인 기능 

    <br/>

- [x] 추첨 결과를 출력하는 기능

    - [x] 수익률 출력하는 기능



<div align = "right">
	<b><a href = "#Contents">↥ top</a></b>
</div>

## 과제를 이해한 후 느낀점

controller에게 너무 과중한 책임이 있다

input값을 받아 작동하는 부분과

그렇지 않는 부분을 나눠서 설계를 할수는 없을까
